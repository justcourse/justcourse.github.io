{"meta":{"title":"For JUST Courses","subtitle":"","description":"","author":"Q. Zh.","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2017-05-09T05:00:48.000Z","updated":"2021-05-04T23:55:16.106Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":"Sorry, but the page you were trying to view does not exist — perhaps you can try searching for it below. var GOOG_FIXURL_LANG = 'en'; var GOOG_FIXURL_SITE = ''"},{"title":"categories","date":"2017-05-09T06:12:45.000Z","updated":"2021-05-04T23:52:22.686Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-09T05:04:41.000Z","updated":"2021-05-04T23:50:21.982Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-05-09T05:04:30.000Z","updated":"2021-05-04T23:54:04.342Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Stay hungry, stay foolish."}],"posts":[{"title":"20210505_工程软件基础总结","slug":"20210505-SummaryofEngineeringSoftwareFoundation","date":"2021-05-05T05:36:17.000Z","updated":"2021-05-05T06:15:11.341Z","comments":true,"path":"2021/05/05/20210505-SummaryofEngineeringSoftwareFoundation/","link":"","permalink":"http://example.com/2021/05/05/20210505-SummaryofEngineeringSoftwareFoundation/","excerpt":"","text":"《工程软件基础》总结Part Ⅰ: 工程软件基础 → 绪论 Part Ⅱ: 工程软件基础 → Matlab部分1.基础语法1.1 分号(;)表示结束语句。但是，如果要抑制和隐藏表达式的MATLAB输出，请在表达式后添加分号。百分号(%)用于注释。例：12x = 3; % 有分号，不会在命令行窗口显示x的值y = x + 5 % 无分号，会在命令行窗口显示y的值 1.2 常用的运算符和特殊字符MATLAB支持以下常用的运算符和特殊字符 - 运算符 使用说明 + 相加; 加法运算符。 - 相减; 减法运算符。 * 标量和矩阵乘法运算符。 .* 阵列乘法运算符。 ^ 标量和矩阵求幂运算符。 .^ 阵列求幂运算符。 \\ 左除法运算符。 / 右除法运算符。 .\\ 阵列左除法运算符。 ./ 右除法运算符。 : 冒号; 生成规则间隔的元素，并表示整个行或列。 ( ) 括号; 包含函数参数和数组索引; 覆盖优先级。 [ ] 括号; 罩住阵列元素。 . 小数点。 … 省略号; 行连续运算符 , 逗号; 分隔一行中的语句和元素 ; 分号; 分隔列并抑制输出显示。 % 百分号;指定一个注释并指定格式。 _ 引用符号和转置运算符。 ._ 非共轭转置运算符。 = 赋值运算符。 1.3 MATLAB支持以下特殊变量和常量： 名称 含义 ans 最近的回应/回答。 eps 浮点精度精度。 i,j 虚构单位$\\sqrt{-1}$。 Inf 无穷 NaN 未定义的数值结果(非数字)。 pi 数字π 1.4 保存变量和加载变量save命令用于在工作空间中保存所有变量，它在当前目录中，以.mat作为扩展名的文件。 例如， 12a = 20;save a 可以随时使用load命令重新加载文件。 1load a 2.Matlab变量 简单分配变量。 声明为向量。 声明为矩阵。 123456789101112131415161718x1 = 12; % 简单变量x2 = [1,2,3,4,5,6]; % 行向量，使用[]x3 = [1,2,3,4,5,6]&#x27;; % 列向量，注意符号 “&#x27;”，该符号表示转置x4 = [1,2,3;4,5,6]; % 矩阵，注意符号 “；”x5 = zeros(3,4); % 声明3行4列0矩阵x6 = ones(5,6); % 声明5行6列1矩阵x7 = linspace(12,17,7) % 声明并初始化行向量，包含 12 到 17 之间的 25 个等间距点:[12.0000 12.8333 13.6667 14.5000 15.3333 16.1667 17.0000]x8 = eye(5) % 创建5*5方阵，对角元素为1，其他元素为0的矩阵x9 = diag([2,5,8]) % 根据向量[2,5,8]创建对角矩阵，即以向量的元素为对角元素x10 = magic(5) % 创建5*5魔方矩阵x11 = rand(3,4) % 创建3*4随机矩阵，在[0,1]区间内服从均匀分布x12 = randn(3,4) % 创建3*4随机矩阵，服从正态分布x13 = randperm() % 创建随机行向量x14 = double([5.32 3.47 6.28]) .* 7.5; % x8为double类型数据：[39.9000 26.0250 47.1000]x15 = 2:0.5:5; % 从2到5之间，每隔0.5取一个数，构成行向量：[2.0 2.5 3.0 3.5 4.0 4.5 5.0]。注意操作符“：”的使用x16 = [&#x27;Fundamentals&#x27;; ... &#x27;of&#x27;; ... &#x27;engineering software&#x27;]; % 声明及初始化字符串矩阵变量 3.Matlab命令3.1 管理会话的命令 命令 描述说明 clc 清除命令窗口 clear 从内存中删除变量 exist 检查文件或变量是否存在 global 声明变量为全局变量 help 搜索帮助主题 3.2 使用系统命令 命令 描述说明 cd 更改当前目录(进入指定目录) date 显示当前日期 delete 删除文件 diary 打开/关闭日记文件记录 dir 列出当前目录下的所有文件 load 从文件加载工作区变量 path 显示搜索路径 pwd 显示当前目录 save 将工作空间变量保存在文件中 type 显示文件的内容 what 列出当前目录中的所有MATLAB文件 wklread 读取.wk1电子表格文件 3.3 输入和输出命令 命令 描述说明 disp 显示数组或字符串的内容 fscanf 从文件读取格式化数据 format 控制屏幕显示格式 fprintf 对屏幕或文件执行格式化的写入 input 显示提示并等待输入 fscanf和fprintf命令的行为类似于C语言中的scanf和printf函数。它们支持以下格式代码 命令 描述说明 %s 格式化为字符串 %d 格式化为字符串整数值 %f 格式化为浮点值 %e 格式化为科学记数法的浮点值 %g 格式最紧凑的形式：%f或%e。 \\n 在输出字符串中插入一个换行 \\t 在输出字符串中插入制表符 格式化(format)函数具有以下用于数字显示的形式 命令 描述说明 format short 4位十进制数(默认) format long 16位数字 format short e 5位数加上指数 format long e 16位加上指数 format bank 两位十进制数字 format + 正，负或零 format rat 有理近似 format compact 禁止一些换行符 format loose 重置为较不紧凑的显示模式 3.4 向量，矩阵和数组命令下表显示了用于处理数组，矩阵和向量的各种命令 - 命令 描述说明 cat 连接数组 find 查找非零元素的索引 length 计算元素数量 linspace 创建规则间隔的向量 logspace 创建对数间隔向量 max 返回最大的元素 min 返回最小的元素 reshape 改变大小 size 计算数组大小 sort 对每列进行排序 sum 对每列进行求和 eye 创建一个单位矩阵 ones 创建一个数组 zeros 创建一个零的数组 det 计算数组的行列式 inv 计算矩阵的逆 pinv 计算矩阵的伪逆 rank 计算矩阵的秩 3.5 绘图命令MATLAB提供了许多用于绘制图形的命令。下表显示了一些常用的绘图命令 - 命令 描述说明 axis 设置轴限制 grid on 显示网格线 plot 生成xy坐标图 title 在文字的顶部放置文字 xlabel 将文本标签添加到x轴 ylabel 将文本标签添加到y轴 axes 创建轴对象 figure 打开一个新的图形窗口 hold on 冻结当前坐标图 hold off 解除冻结当前坐标图 set 指定诸如轴的对象的属性 subplot 在子窗口中创建图 text 在图开放置字符串 4.Matlab中的运算4.1 算术运算符 运算符 描述说明 + 加法或一元加法运算。 - 减法或一元减法运算。 * 矩阵乘法 .* 按元素相乘，两矩阵行列数需相同 / 矩阵右除。 ./ 按元素右除，两矩阵行列数需相同。 \\ 矩阵左除（也称为反斜杠）。 .\\ 按元素左除，两矩阵行列数需相同。 ^ 矩阵幂 .^ 按元素求幂，两矩阵行列数需相同。 &#39; 转置。 .&#39; 复共轭转置。 4.2 关系运算符 操作符 说明描述 == 等于 ~= 不等于 4.3 逻辑运算符符号&amp;&amp;和||是逻辑运算符AND和OR，常用于if及while语句。 4.4 位运算 操作符 说明描述 &amp; 按位与 ` ` ^ 按位异或 ~ 按位非 5.语句5.1 条件语句 语句 描述 if…end语句 if ... end语句包含一个布尔表达式，后跟一个或多个语句。 if…else…end语句 if语句可以跟随一个可选的else语句，当布尔表达式为false时，else语句块将执行。 if…elseif…elseif…else…end语句 if语句后面可以有一个(或多个)可选elseif ...和一个else语句，这对于测试各种条件非常有用。 嵌套if语句 可以在一个if或elseif语句中使用另一个if或elseif语句。 switch语句 switch语句用来测试一个变量与值列表的相等性。 嵌套switch语句 可以在一个switch语句中使用一个switch语句。 5.2 循环迭代语句 循环类型 描述 while循环 在给定条件为真时，重复一个语句或一组语句。它在执行循环体之前测试状态。 for循环 多次执行一系列语句，并缩写管理循环变量的代码。 嵌套循环 在任何循环中使用另外一个或多个循环。 5.3 跳转语句 语句 描述 return 跳出整个函数，函数中return之后的代码都不执行。 break 跳出最近的循环语句。 continue 跳出循环的当前执行，继续从头执行下一次循环。 6.脚本和函数6.1 脚本将m语句存储为filename.m文件，则该文件filename.m称之为一个脚本。 6.2 函数Matlab的函数书写规则如下： 1function [out1,out2, ..., outN] &#x3D; myFunName(in1,in2,in3, ..., inN) 该函数及实现存储为myFunName.m，形成函数myFunName，可供外部调用。注意，此时.m文件的文件名必须与函数名相同！ 例如： 12function z &#x3D; myaddfun(x,y)z &#x3D; x + y; 该函数必须存储为myaddfun.m，才能被调用。 7.Matlab绘图Matlab的plot，plot3，mesh均可以用于绘图。其中，plot用于绘制二维曲线，plot3用于绘制三维曲线，mesh用于绘制三维网格。 7.1 plot使用示例123456789101112131415161718192021222324252627282930313233343536373839404142% 初始化变量x = -pi:pi/15:pi;y1 = sin(x);y2 = sin(2*x);y3 = cos(3*x);y4 = tan(sin(x)) - sin(tan(x));% 使用plot绘制figure(1)figure(1);hold on;plot(x,y1);plot(x,y2);plot(x,y3);plot(x,y4);axis([-4 4.5 -1.1 3])legend(&#x27;sin(x)&#x27;,&#x27;sin(2x)&#x27;,&#x27;cos(3x)&#x27;,&#x27;tan(sin(x)) - sin(tan(x))&#x27;)hold off;% 使用plot绘制figure(2)，内含4个子图figure(2);subplot(2,2,1);plot(x,y1);axis([-3.5 3.5 -1.1 1.1]);title(&#x27;2-D Line Plot&#x27;)xlabel(&#x27;x&#x27;)ylabel(&#x27;sin(x)&#x27;)grid on;subplot(2,2,2);plot(x,y1,x,y2,&#x27;--&#x27;,x,y3,&#x27;:&#x27;)subplot(2,2,3);plot(x,y1,&#x27;g&#x27;,x,y2,&#x27;b--o&#x27;,x,y3,&#x27;c*&#x27;)subplot(2,2,4);plot(x,y4,&#x27;--gs&#x27;,... &#x27;LineWidth&#x27;,2,... &#x27;MarkerSize&#x27;,3,... &#x27;MarkerEdgeColor&#x27;,&#x27;b&#x27;,... &#x27;MarkerFaceColor&#x27;,[0.5,0.5,0.5]) 7.2 plot3示例123456789% 初始化变量x &#x3D; -pi:pi&#x2F;15:pi;y1 &#x3D; sin(x);y2 &#x3D; sin(2*x);y3 &#x3D; cos(3*x);% 使用plot3绘制figure(3)，plot3为绘制空间中三维点的曲线figure(3)plot3(y1,y2,y3); 7.3 mesh示例123456% 初始化变量[A,B,C] &#x3D; peaks(25);% 使用mesh绘制figure(4)，mesh为绘制空间中三维曲面figure(4)mesh(A,B,C) 8.Matlab求解多项式的根Matalb可以使用roots()函数求解多项式的根。 例如：对于多项式$2x^5 + x^4 - 7x^3 - 5x + 9 = 0$求解，代码如下： 12p = [2, 1, -7, 0, -5, 9];s = roots(p) 9.Matlab求解函数的极限Matalb可以使用limit()求解函数的极限。 例如:$f(x)= x^2 cos(x)$求解：$\\lim_{x \\to 4} f(x)$ 123syms xf=x^2*cos(x);limit(f, 4) 10.Matlab求解函数微分Matalb可以使用diff()求解函数的微分。 例如，求解$f(x,y)= x^2 cos(x)$对$x$的一阶和二阶导数。 1234syms xf=x^2*cos(x);diff(f,x) % 一阶导diff(f,x,2) % 二阶导 例如，分别求解$f(x,y)= x^2ycos(x)+y^2$对$x$和$y$的偏微分。 12345syms xsyms yf=x^2*y*cos(x)+y^2;dx = diff(f,x) % f对x的偏导dy = diff(f,y) % f对y的偏导 11.Matlab求解函数积分Matalb可以使用int()求解函数的积分。 11.1 求解不定积分例如，求解$\\int 2xcos(x) - x^2sin(x)dx$ 123syms xf=2*x*cos(x) - x^2*sin(x)int(f) 11.2 求解定积分例如，求解$\\int_{1}^{2} 2xcos(x) - x^2sin(x)dx$ 123syms xf&#x3D;2*x*cos(x) - x^2*sin(x)a &#x3D; int(f, 1, 2) 12.Simulink部分Simulink为Matlab的可视化仿真环境，具体参考课程PPT及课程实验。 Part Ⅲ: 工程软件基础 → Proteus部分Proteus为Lab Center Electronics公司的EDA工具软件，具备Schematic Capture、PCB Layout、Gerbit 三大结构体，可实现原理图设计、仿真、PCB设计等功能。Proteus的体系结构如下图所示。 具体参考课程PPT及课程实验。","categories":[{"name":"工程软件基础","slug":"工程软件基础","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"工程软件基础","slug":"工程软件基础","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/"}]},{"title":"MCU Experiment 2 - 8051 Programming Language","slug":"20210504-MCUExperiment2-8051ProgrammingLanguage","date":"2021-05-04T14:51:05.000Z","updated":"2021-05-04T14:58:42.891Z","comments":true,"path":"2021/05/04/20210504-MCUExperiment2-8051ProgrammingLanguage/","link":"","permalink":"http://example.com/2021/05/04/20210504-MCUExperiment2-8051ProgrammingLanguage/","excerpt":"","text":"1.ContentsLearn the programming techniques of the three structures of a program, and be able to use the basic structure to implement common programs such as code conversion and table lookup. 2.Basic principleAssembly Language is a pseudo-English representation of the Machine Language. The 8051 Microcontroller Assembly Language is a combination of English like words called Mnemonics and Hexadecimal codes. It is also a low level language and requires extensive understanding of the architecture of the Microcontroller. Although High-level languages are easy to work with, the following reasons point out the advantage of Assembly Language: The Programs written in Assembly gets executed faster and they occupy less memory. With the help of Assembly Language, you can directly exploit all the features of a Microcontroller. Using Assembly Language, you can have direct and accurate control of all the Microcontroller’s resources like I/O Ports, RAM, SFRs, etc. Compared to High-level Languages, Assembly Language has less rules and restrictions. 3.Experimental stepsPlease refer to the file “Experiment 2.docx“ 4.Experiment results and analysisPlease record experiment results and analyze the results.","categories":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/categories/MCU/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/tags/MCU/"}]},{"title":"MCU Experiment 1 - Establish Environment","slug":"20210504-MCUExperiment1-EstablishEnvironment","date":"2021-05-04T14:17:35.000Z","updated":"2021-05-04T14:42:13.911Z","comments":true,"path":"2021/05/04/20210504-MCUExperiment1-EstablishEnvironment/","link":"","permalink":"http://example.com/2021/05/04/20210504-MCUExperiment1-EstablishEnvironment/","excerpt":"","text":"1.ContentsTo understand programming environment of MCU, master the debugging method of MCU instruction, and learn the basic programming technology of MCU. 2.Basic principleKeil and Proteus are used to program and simulate 8051 serial single chip microcontroller. 8051 microcontroller needs Keil software for its programming. Programming can be done in C language or assembly language. Proteus is a proprietary software tool suite used primarily for electronic design automation. The software is used mainly by electronic design engineers and technicians to create schematics and electronic prints for manufacturing printed circuit boards. The micro-controller simulation in Proteus works by applying either a hex file or a debug file to the microcontroller part on the schematic. It is then co-simulated along with any analog and digital electronics connected to it. This enables its use in a broad spectrum of project prototyping in areas such as motor control, temperature control and user interface design. It also finds use in the general hobbyist community and, since no hardware is required, is convenient to use as a training or teaching tool. 8051 serial MCU is supported for co-simulation. 3.Experimental stepsPlease refer to the file “Experiment 1.docx“ 4.Experiment results and analysisPlease record experiment results and analyze the results.","categories":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/categories/MCU/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/tags/MCU/"}]},{"title":"Python写HDF5文件","slug":"20170518-Python写HDF5文件","date":"2017-05-18T12:35:02.000Z","updated":"2021-05-04T14:13:28.559Z","comments":true,"path":"2017/05/18/20170518-Python写HDF5文件/","link":"","permalink":"http://example.com/2017/05/18/20170518-Python%E5%86%99HDF5%E6%96%87%E4%BB%B6/","excerpt":"","text":"采用Caffe实现多float标签回归时需要采用HDF5数据存储方式。本文归纳了Python读取图像数据和标签，并写入HDF5文件的过程。 假设有 labels.txt 存储标签如下： 12img0.jpg 0 10.5 20.5 30.5 40.5img1.jpg 1 9.5 19.5 29.5 39.5 Python写HDF5文件的代码如下： 1234567891011121314151617181920212223242526272829import h5py as hpimport numpy as npimport cv2h5filesize = 10 #修改该值，使HDF5文件小于2GBwidth = 448height = 448fid = open(&#x27;labels.txt&#x27;)lines = fid.readlines()f = hp.File(&#x27;HDF5_FILE.h5&#x27;, &#x27;w&#x27;)imgData = np.zeros((h5filesize, 3, height, width))labels = np.zeros((h5filesize, 5))#标签的长度为5idx=0for line in lines: line = line.strip().split() image = cv2.imread(line[0])#Caffe中图像为BGR，即imread获得的图像channel的顺序 image = cv2.resize(image,(width, height)) image = image.transpose((h5filesize, 0, 1))#转换为Caffe中数据的存储顺序：C,H,W imgData[idx, :, :, :] = image labels[idx, 0] = float(line[1]) labels[idx, 1] = float(line[2]) labels[idx, 2] = float(line[3]) labels[idx, 3] = float(line[4]) labels[idx, 4] = float(line[4]) idx + 1f[&#x27;data&#x27;] = imgDataf[&#x27;label&#x27;] = labelsfid.close()f.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"HDF5","slug":"HDF5","permalink":"http://example.com/tags/HDF5/"}]},{"title":"Eigen与Matlab对应函数列表","slug":"20170517-Eigen与Matlab对应函数列表","date":"2017-05-17T08:43:52.000Z","updated":"2021-05-04T14:13:03.547Z","comments":true,"path":"2017/05/17/20170517-Eigen与Matlab对应函数列表/","link":"","permalink":"http://example.com/2017/05/17/20170517-Eigen%E4%B8%8EMatlab%E5%AF%B9%E5%BA%94%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8/","excerpt":"","text":"C++矩阵运算开源库Eigen与Matlab对应函数列表作者：Keir Mierle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207// A simple quickref for Eigen. Add anything that&#x27;s missing.// Main author: Keir Mierle#include &lt;Eigen/Dense&gt;Matrix&lt;double, 3, 3&gt; A; // Fixed rows and cols. Same as Matrix3d.Matrix&lt;double, 3, Dynamic&gt; B; // Fixed rows, dynamic cols.Matrix&lt;double, Dynamic, Dynamic&gt; C; // Full dynamic. Same as MatrixXd.Matrix&lt;double, 3, 3, RowMajor&gt; E; // Row major; default is column-major.Matrix3f P, Q, R; // 3x3 float matrix.Vector3f x, y, z; // 3x1 float matrix.RowVector3f a, b, c; // 1x3 float matrix.VectorXd v; // Dynamic column vector of doublesdouble s;// Basic usage// Eigen // Matlab // commentsx.size() // length(x) // vector sizeC.rows() // size(C,1) // number of rowsC.cols() // size(C,2) // number of columnsx(i) // x(i+1) // Matlab is 1-basedC(i,j) // C(i+1,j+1) //A.resize(4, 4); // Runtime error if assertions are on.B.resize(4, 9); // Runtime error if assertions are on.A.resize(3, 3); // Ok; size didn&#x27;t change.B.resize(3, 9); // Ok; only dynamic cols changed.A &lt;&lt; 1, 2, 3, // Initialize A. The elements can also be 4, 5, 6, // matrices, which are stacked along cols 7, 8, 9; // and then the rows are stacked.B &lt;&lt; A, A, A; // B is three horizontally stacked A&#x27;s.A.fill(10); // Fill A with all 10&#x27;s.// Eigen // MatlabMatrixXd::Identity(rows,cols) // eye(rows,cols)C.setIdentity(rows,cols) // C = eye(rows,cols)MatrixXd::Zero(rows,cols) // zeros(rows,cols)C.setZero(rows,cols) // C = ones(rows,cols)MatrixXd::Ones(rows,cols) // ones(rows,cols)C.setOnes(rows,cols) // C = ones(rows,cols)MatrixXd::Random(rows,cols) // rand(rows,cols)*2-1 // MatrixXd::Random returns uniform random numbers in (-1, 1).C.setRandom(rows,cols) // C = rand(rows,cols)*2-1VectorXd::LinSpaced(size,low,high) // linspace(low,high,size)&#x27;v.setLinSpaced(size,low,high) // v = linspace(low,high,size)&#x27;// Matrix slicing and blocks. All expressions listed here are read/write.// Templated size versions are faster. Note that Matlab is 1-based (a size N// vector is x(1)...x(N)).// Eigen // Matlabx.head(n) // x(1:n)x.head&lt;n&gt;() // x(1:n)x.tail(n) // x(end - n + 1: end)x.tail&lt;n&gt;() // x(end - n + 1: end)x.segment(i, n) // x(i+1 : i+n)x.segment&lt;n&gt;(i) // x(i+1 : i+n)P.block(i, j, rows, cols) // P(i+1 : i+rows, j+1 : j+cols)P.block&lt;rows, cols&gt;(i, j) // P(i+1 : i+rows, j+1 : j+cols)P.row(i) // P(i+1, :)P.col(j) // P(:, j+1)P.leftCols&lt;cols&gt;() // P(:, 1:cols)P.leftCols(cols) // P(:, 1:cols)P.middleCols&lt;cols&gt;(j) // P(:, j+1:j+cols)P.middleCols(j, cols) // P(:, j+1:j+cols)P.rightCols&lt;cols&gt;() // P(:, end-cols+1:end)P.rightCols(cols) // P(:, end-cols+1:end)P.topRows&lt;rows&gt;() // P(1:rows, :)P.topRows(rows) // P(1:rows, :)P.middleRows&lt;rows&gt;(i) // P(:, i+1:i+rows)P.middleRows(i, rows) // P(:, i+1:i+rows)P.bottomRows&lt;rows&gt;() // P(:, end-rows+1:end)P.bottomRows(rows) // P(:, end-rows+1:end)P.topLeftCorner(rows, cols) // P(1:rows, 1:cols)P.topRightCorner(rows, cols) // P(1:rows, end-cols+1:end)P.bottomLeftCorner(rows, cols) // P(end-rows+1:end, 1:cols)P.bottomRightCorner(rows, cols) // P(end-rows+1:end, end-cols+1:end)P.topLeftCorner&lt;rows,cols&gt;() // P(1:rows, 1:cols)P.topRightCorner&lt;rows,cols&gt;() // P(1:rows, end-cols+1:end)P.bottomLeftCorner&lt;rows,cols&gt;() // P(end-rows+1:end, 1:cols)P.bottomRightCorner&lt;rows,cols&gt;() // P(end-rows+1:end, end-cols+1:end)// Of particular note is Eigen&#x27;s swap function which is highly optimized.// Eigen // MatlabR.row(i) = P.col(j); // R(i, :) = P(:, i)R.col(j1).swap(mat1.col(j2)); // R(:, [j1 j2]) = R(:, [j2, j1])// Views, transpose, etc; all read-write except for .adjoint().// Eigen // MatlabR.adjoint() // R&#x27;R.transpose() // R.&#x27; or conj(R&#x27;)R.diagonal() // diag(R)x.asDiagonal() // diag(x)R.transpose().colwise().reverse(); // rot90(R)R.conjugate() // conj(R)// All the same as Matlab, but matlab doesn&#x27;t have *= style operators.// Matrix-vector. Matrix-matrix. Matrix-scalar.y = M*x; R = P*Q; R = P*s;a = b*M; R = P - Q; R = s*P;a *= M; R = P + Q; R = P/s; R *= Q; R = s*P; R += Q; R *= s; R -= Q; R /= s;// Vectorized operations on each element independently// Eigen // MatlabR = P.cwiseProduct(Q); // R = P .* QR = P.array() * s.array();// R = P .* sR = P.cwiseQuotient(Q); // R = P ./ QR = P.array() / Q.array();// R = P ./ QR = P.array() + s.array();// R = P + sR = P.array() - s.array();// R = P - sR.array() += s; // R = R + sR.array() -= s; // R = R - sR.array() &lt; Q.array(); // R &lt; QR.array() &lt;= Q.array(); // R &lt;= QR.cwiseInverse(); // 1 ./ PR.array().inverse(); // 1 ./ PR.array().sin() // sin(P)R.array().cos() // cos(P)R.array().pow(s) // P .^ sR.array().square() // P .^ 2R.array().cube() // P .^ 3R.cwiseSqrt() // sqrt(P)R.array().sqrt() // sqrt(P)R.array().exp() // exp(P)R.array().log() // log(P)R.cwiseMax(P) // max(R, P)R.array().max(P.array()) // max(R, P)R.cwiseMin(P) // min(R, P)R.array().min(P.array()) // min(R, P)R.cwiseAbs() // abs(P)R.array().abs() // abs(P)R.cwiseAbs2() // abs(P.^2)R.array().abs2() // abs(P.^2)(R.array() &lt; s).select(P,Q); // (R &lt; s ? P : Q)// Reductions.int r, c;// Eigen // MatlabR.minCoeff() // min(R(:))R.maxCoeff() // max(R(:))s = R.minCoeff(&amp;r, &amp;c) // [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);s = R.maxCoeff(&amp;r, &amp;c) // [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);R.sum() // sum(R(:))R.colwise().sum() // sum(R)R.rowwise().sum() // sum(R, 2) or sum(R&#x27;)&#x27;R.prod() // prod(R(:))R.colwise().prod() // prod(R)R.rowwise().prod() // prod(R, 2) or prod(R&#x27;)&#x27;R.trace() // trace(R)R.all() // all(R(:))R.colwise().all() // all(R)R.rowwise().all() // all(R, 2)R.any() // any(R(:))R.colwise().any() // any(R)R.rowwise().any() // any(R, 2)// Dot products, norms, etc.// Eigen // Matlabx.norm() // norm(x). Note that norm(R) doesn&#x27;t work in Eigen.x.squaredNorm() // dot(x, x) Note the equivalence is not true for complexx.dot(y) // dot(x, y)x.cross(y) // cross(x, y) Requires #include &lt;Eigen/Geometry&gt;//// Type conversion// Eigen // MatlabA.cast&lt;double&gt;(); // double(A)A.cast&lt;float&gt;(); // single(A)A.cast&lt;int&gt;(); // int32(A)A.real(); // real(A)A.imag(); // imag(A)// if the original type equals destination type, no work is done// Note that for most operations Eigen requires all operands to have the same type:MatrixXf F = MatrixXf::Zero(3,3);A += F; // illegal in Eigen. In Matlab A = A+F is allowedA += F.cast&lt;double&gt;(); // F converted to double and then added (generally, conversion happens on-the-fly)// Eigen can map existing memory into Eigen matrices.float array[3];Vector3f::Map(array).fill(10); // create a temporary Map over array and sets entries to 10int data[4] = &#123;1, 2, 3, 4&#125;;Matrix2i mat2x2(data); // copies data into mat2x2Matrix2i::Map(data) = 2*mat2x2; // overwrite elements of data with 2*mat2x2MatrixXi::Map(data, 2, 2) += mat2x2; // adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)// Solve Ax = b. Result stored in x. Matlab: x = A \\ b.x = A.ldlt().solve(b)); // A sym. p.s.d. #include &lt;Eigen/Cholesky&gt;x = A.llt() .solve(b)); // A sym. p.d. #include &lt;Eigen/Cholesky&gt;x = A.lu() .solve(b)); // Stable and fast. #include &lt;Eigen/LU&gt;x = A.qr() .solve(b)); // No pivoting. #include &lt;Eigen/QR&gt;x = A.svd() .solve(b)); // Stable, slowest. #include &lt;Eigen/SVD&gt;// .ldlt() -&gt; .matrixL() and .matrixD()// .llt() -&gt; .matrixL()// .lu() -&gt; .matrixL() and .matrixU()// .qr() -&gt; .matrixQ() and .matrixR()// .svd() -&gt; .matrixU(), .singularValues(), and .matrixV()// Eigenvalue problems// Eigen // MatlabA.eigenvalues(); // eig(A);EigenSolver&lt;Matrix3d&gt; eig(A); // [vec val] = eig(A)eig.eigenvalues(); // diag(val)eig.eigenvectors(); // vec// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"CMakeLists.txt中声明使用C++11标准","slug":"20170509-CMakeLists.txt-使用C++11标准","date":"2017-05-09T04:05:32.000Z","updated":"2021-05-04T14:12:19.683Z","comments":true,"path":"2017/05/09/20170509-CMakeLists.txt-使用C++11标准/","link":"","permalink":"http://example.com/2017/05/09/20170509-CMakeLists.txt-%E4%BD%BF%E7%94%A8C++11%E6%A0%87%E5%87%86/","excerpt":"","text":"在CMakeLists.txt中添加如下代码： 1add_definitions(-std&#x3D;c++11) 即可。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"http://example.com/tags/cmake/"},{"name":"c++11","slug":"c-11","permalink":"http://example.com/tags/c-11/"}]},{"title":"Git命令行操作指南——上传项目","slug":"20170509-Git-命令使用指南","date":"2017-05-09T01:24:07.000Z","updated":"2021-05-04T14:27:35.663Z","comments":true,"path":"2017/05/09/20170509-Git-命令使用指南/","link":"","permalink":"http://example.com/2017/05/09/20170509-Git-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"假设已经在github上创建了项目名，地址为:https://github.com/xx/xx.git 1.创建项目目录并初始化123mkdir *** #项目文件夹cd ***git init 2.将所有文件添加到暂存区1git add . 3.将暂存区的文件提交至本地仓库1git commit -m “注释&quot; 4.将本地仓库关联到Github上1git remote add origin https://github.com/xx/xx.git 5.将代码由本地仓库上传到Github远程仓库12git pull --rebase origin mastergit push -u origin master","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"Hexo文章排序","slug":"20170502-Hexo文章排序","date":"2017-05-02T06:10:35.000Z","updated":"2021-05-04T14:12:00.151Z","comments":true,"path":"2017/05/02/20170502-Hexo文章排序/","link":"","permalink":"http://example.com/2017/05/02/20170502-Hexo%E6%96%87%E7%AB%A0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"修改文件夹中的 node_modules/hexo-generator-index/lib/generator.js文件，在var posts一句后面加入如下代码 1234567891011posts.data &#x3D; posts.data.sort(function(first, second) &#123; if (first.top &amp;&amp; second.top) &#123; &#x2F;&#x2F; 两篇文章top都有定义 return first.top &#x3D;&#x3D; second.top ? second.date - first.date : second.top - first.top &#x2F;&#x2F;若top值一样则按照文章日期降序排, 否则按照top值降序排 &#125; else if (first.top &amp;&amp; !second.top) &#123; &#x2F;&#x2F; 以下是只有一篇文章top有定义，将有top的排在前面 return -1; &#125; else if (!first.top &amp;&amp; second.top) &#123; return 1; &#125; else &#123; return second.date - first.date; &#x2F;&#x2F; 都没定义top，按照文章日期降序排 &#125; &#125;); 修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334&#39;use strict&#39;;var pagination &#x3D; require(&#39;hexo-pagination&#39;);module.exports &#x3D; function(locals) &#123; var config &#x3D; this.config; var posts &#x3D; locals.posts.sort(config.index_generator.order_by); posts.data &#x3D; posts.data.sort(function(first, second) &#123; if (first.top &amp;&amp; second.top) &#123; return first.top &#x3D;&#x3D; second.top ? second.date - first.date : second.top - first.top &#125; else if (first.top &amp;&amp; !second.top) &#123; return -1; &#125; else if (!first.top &amp;&amp; second.top) &#123; return 1; &#125; else &#123; return second.date - first.date; &#125; &#125;); var paginationDir &#x3D; config.pagination_dir || &#39;page&#39;; var path &#x3D; config.index_generator.path || &#39;&#39;; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: [&#39;index&#39;, &#39;archive&#39;], format: paginationDir + &#39;&#x2F;%d&#x2F;&#39;, data: &#123; __index: true &#125; &#125;);&#125;; 2.在Markdown文件头位置，加入如下配置 1top: 数字 #数字越大，排名越靠前。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Hexo 建立个人博客","slug":"20170501-Hexo-建立个人博客","date":"2017-05-01T06:17:35.000Z","updated":"2021-05-04T14:11:50.779Z","comments":true,"path":"2017/05/01/20170501-Hexo-建立个人博客/","link":"","permalink":"http://example.com/2017/05/01/20170501-Hexo-%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"假设已经在github上创建了项目，项目名为abc.github.io Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1. 安装Git1sudo apt-get install git 2. 安装nodejs12sudo apt-get install nodejssudo apt-get install npm 3. 安装hexo安装hexo，输入命令 123mkdir myblogcd myblognpm install -g hexo-cli 初始化hexo 12hexo init myblognpm install 完成后，文件夹目录包含如下： 123456node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件 123hexo cleanhexo ghexo s 清理、生成网页，打开hexo的服务，在浏览器输入localhost:4000可以看到生成的博客。 4. GitHub创建个人仓库注册并登录github后，新建仓库New repository 创建与用户名相同的仓库，如：abc.github.io，其中abc为GitHub用户名。 点击create repository。 5. 生成SSH添加到GitHub回到shell，输入以下命令： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; yourname为GitHub的用户名，youremail为GitHub的邮箱，该操作用于github对用户名和邮箱信息进行匹配验证。 检查上述name和email是否正确 12git config user.namegit config user.email 创建SSH 1ssh-keygen -t rsa -C &quot;youremail&quot; 生成~/.ssh的文件夹及密钥文件。 在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key。 复制SSH生成的id_rsa.pub中的信息并粘贴到文本框中。 6. 将hexo部署到GitHub运行如下命令，适中保存github用户名和密码 1git config --global credential.helper store 修改配置文件_config.yml 1234deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;abc.github.io.git branch: main 安装deploy-git 1npm install hexo-deployer-git --save 使用hexo命令清理、生成、部署博客网页 123hexo cleanhexo ghexo d 必要时输入username和password。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Create New Page","slug":"20170420-CreateNewPage","date":"2017-04-20T06:17:35.000Z","updated":"2021-05-05T01:33:36.649Z","comments":true,"path":"2017/04/20/20170420-CreateNewPage/","link":"","permalink":"http://example.com/2017/04/20/20170420-CreateNewPage/","excerpt":"","text":"This is the title.This is a code block.123456int fun(int x, int y)&#123; int z = -32768; z = x + y; return z;&#125; This is a table. Variable Value a 10 b 20 This is a math equation$$ \\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$$ This is a mermaid chartpie title Key elements in Product X &quot;Calcium&quot; : 42.96 &quot;Potassium&quot; : 50.05 &quot;Magnesium&quot; : 10.01 &quot;Iron&quot; : 5 This is an image","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"工程软件基础","slug":"工程软件基础","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/"},{"name":"MCU","slug":"MCU","permalink":"http://example.com/categories/MCU/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"工程软件基础","slug":"工程软件基础","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/"},{"name":"MCU","slug":"MCU","permalink":"http://example.com/tags/MCU/"},{"name":"HDF5","slug":"HDF5","permalink":"http://example.com/tags/HDF5/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"cmake","slug":"cmake","permalink":"http://example.com/tags/cmake/"},{"name":"c++11","slug":"c-11","permalink":"http://example.com/tags/c-11/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}