{"meta":{"title":"For JUST Courses","subtitle":"","description":"","author":"Q. Zh.","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2017-05-09T05:00:48.000Z","updated":"2017-05-09T05:00:48.233Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-09T05:04:41.000Z","updated":"2017-05-09T05:04:41.354Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2017-05-09T05:04:30.000Z","updated":"2017-12-27T03:08:39.628Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Stay hungry, stay foolish."}],"posts":[{"title":"MCU Experiment 3 - Parallel Interface","slug":"20210504-MCUExperiment3-ParalelPortProgramming","date":"2021-05-04T14:54:12.000Z","updated":"2021-05-04T15:00:18.795Z","comments":true,"path":"2021/05/04/20210504-MCUExperiment3-ParalelPortProgramming/","link":"","permalink":"http://example.com/2021/05/04/20210504-MCUExperiment3-ParalelPortProgramming/","excerpt":"","text":"1.ContentsMaster the programming of the parallel I/O ports. 2.Basic principle and Experimental stepsPlease refer to the following files: Experiment 3.docx Tutorials for Parallel IO Programming.docx ParellelPortProgramming_Projects.zip 3.Experiment results and analysisPlease record experiment results and analyze the results.","categories":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/categories/MCU/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/tags/MCU/"}]},{"title":"MCU Experiment 2 - 8051 Programming Language","slug":"20210504-MCUExperiment2-8051ProgrammingLanguage","date":"2021-05-04T14:51:05.000Z","updated":"2021-05-04T14:58:42.891Z","comments":true,"path":"2021/05/04/20210504-MCUExperiment2-8051ProgrammingLanguage/","link":"","permalink":"http://example.com/2021/05/04/20210504-MCUExperiment2-8051ProgrammingLanguage/","excerpt":"","text":"1.ContentsLearn the programming techniques of the three structures of a program, and be able to use the basic structure to implement common programs such as code conversion and table lookup. 2.Basic principleAssembly Language is a pseudo-English representation of the Machine Language. The 8051 Microcontroller Assembly Language is a combination of English like words called Mnemonics and Hexadecimal codes. It is also a low level language and requires extensive understanding of the architecture of the Microcontroller. Although High-level languages are easy to work with, the following reasons point out the advantage of Assembly Language: The Programs written in Assembly gets executed faster and they occupy less memory. With the help of Assembly Language, you can directly exploit all the features of a Microcontroller. Using Assembly Language, you can have direct and accurate control of all the Microcontroller’s resources like I/O Ports, RAM, SFRs, etc. Compared to High-level Languages, Assembly Language has less rules and restrictions. 3.Experimental stepsPlease refer to the file “Experiment 2.docx“ 4.Experiment results and analysisPlease record experiment results and analyze the results.","categories":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/categories/MCU/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/tags/MCU/"}]},{"title":"MCU Experiment 1 - Establish Environment","slug":"20210504-MCUExperiment1-EstablishEnvironment","date":"2021-05-04T14:17:35.000Z","updated":"2021-05-04T14:42:13.911Z","comments":true,"path":"2021/05/04/20210504-MCUExperiment1-EstablishEnvironment/","link":"","permalink":"http://example.com/2021/05/04/20210504-MCUExperiment1-EstablishEnvironment/","excerpt":"","text":"1.ContentsTo understand programming environment of MCU, master the debugging method of MCU instruction, and learn the basic programming technology of MCU. 2.Basic principleKeil and Proteus are used to program and simulate 8051 serial single chip microcontroller. 8051 microcontroller needs Keil software for its programming. Programming can be done in C language or assembly language. Proteus is a proprietary software tool suite used primarily for electronic design automation. The software is used mainly by electronic design engineers and technicians to create schematics and electronic prints for manufacturing printed circuit boards. The micro-controller simulation in Proteus works by applying either a hex file or a debug file to the microcontroller part on the schematic. It is then co-simulated along with any analog and digital electronics connected to it. This enables its use in a broad spectrum of project prototyping in areas such as motor control, temperature control and user interface design. It also finds use in the general hobbyist community and, since no hardware is required, is convenient to use as a training or teaching tool. 8051 serial MCU is supported for co-simulation. 3.Experimental stepsPlease refer to the file “Experiment 1.docx“ 4.Experiment results and analysisPlease record experiment results and analyze the results.","categories":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/categories/MCU/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/tags/MCU/"}]},{"title":"Python写HDF5文件","slug":"20170518-Python写HDF5文件","date":"2017-05-18T12:35:02.000Z","updated":"2021-05-04T14:13:28.559Z","comments":true,"path":"2017/05/18/20170518-Python写HDF5文件/","link":"","permalink":"http://example.com/2017/05/18/20170518-Python%E5%86%99HDF5%E6%96%87%E4%BB%B6/","excerpt":"","text":"采用Caffe实现多float标签回归时需要采用HDF5数据存储方式。本文归纳了Python读取图像数据和标签，并写入HDF5文件的过程。 假设有 labels.txt 存储标签如下： 12img0.jpg 0 10.5 20.5 30.5 40.5img1.jpg 1 9.5 19.5 29.5 39.5 Python写HDF5文件的代码如下： 1234567891011121314151617181920212223242526272829import h5py as hpimport numpy as npimport cv2h5filesize = 10 #修改该值，使HDF5文件小于2GBwidth = 448height = 448fid = open(&#x27;labels.txt&#x27;)lines = fid.readlines()f = hp.File(&#x27;HDF5_FILE.h5&#x27;, &#x27;w&#x27;)imgData = np.zeros((h5filesize, 3, height, width))labels = np.zeros((h5filesize, 5))#标签的长度为5idx=0for line in lines: line = line.strip().split() image = cv2.imread(line[0])#Caffe中图像为BGR，即imread获得的图像channel的顺序 image = cv2.resize(image,(width, height)) image = image.transpose((h5filesize, 0, 1))#转换为Caffe中数据的存储顺序：C,H,W imgData[idx, :, :, :] = image labels[idx, 0] = float(line[1]) labels[idx, 1] = float(line[2]) labels[idx, 2] = float(line[3]) labels[idx, 3] = float(line[4]) labels[idx, 4] = float(line[4]) idx + 1f[&#x27;data&#x27;] = imgDataf[&#x27;label&#x27;] = labelsfid.close()f.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"HDF5","slug":"HDF5","permalink":"http://example.com/tags/HDF5/"}]},{"title":"Eigen与Matlab对应函数列表","slug":"20170517-Eigen与Matlab对应函数列表","date":"2017-05-17T08:43:52.000Z","updated":"2021-05-04T14:13:03.547Z","comments":true,"path":"2017/05/17/20170517-Eigen与Matlab对应函数列表/","link":"","permalink":"http://example.com/2017/05/17/20170517-Eigen%E4%B8%8EMatlab%E5%AF%B9%E5%BA%94%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8/","excerpt":"","text":"C++矩阵运算开源库Eigen与Matlab对应函数列表作者：Keir Mierle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207// A simple quickref for Eigen. Add anything that&#x27;s missing.// Main author: Keir Mierle#include &lt;Eigen/Dense&gt;Matrix&lt;double, 3, 3&gt; A; // Fixed rows and cols. Same as Matrix3d.Matrix&lt;double, 3, Dynamic&gt; B; // Fixed rows, dynamic cols.Matrix&lt;double, Dynamic, Dynamic&gt; C; // Full dynamic. Same as MatrixXd.Matrix&lt;double, 3, 3, RowMajor&gt; E; // Row major; default is column-major.Matrix3f P, Q, R; // 3x3 float matrix.Vector3f x, y, z; // 3x1 float matrix.RowVector3f a, b, c; // 1x3 float matrix.VectorXd v; // Dynamic column vector of doublesdouble s;// Basic usage// Eigen // Matlab // commentsx.size() // length(x) // vector sizeC.rows() // size(C,1) // number of rowsC.cols() // size(C,2) // number of columnsx(i) // x(i+1) // Matlab is 1-basedC(i,j) // C(i+1,j+1) //A.resize(4, 4); // Runtime error if assertions are on.B.resize(4, 9); // Runtime error if assertions are on.A.resize(3, 3); // Ok; size didn&#x27;t change.B.resize(3, 9); // Ok; only dynamic cols changed.A &lt;&lt; 1, 2, 3, // Initialize A. The elements can also be 4, 5, 6, // matrices, which are stacked along cols 7, 8, 9; // and then the rows are stacked.B &lt;&lt; A, A, A; // B is three horizontally stacked A&#x27;s.A.fill(10); // Fill A with all 10&#x27;s.// Eigen // MatlabMatrixXd::Identity(rows,cols) // eye(rows,cols)C.setIdentity(rows,cols) // C = eye(rows,cols)MatrixXd::Zero(rows,cols) // zeros(rows,cols)C.setZero(rows,cols) // C = ones(rows,cols)MatrixXd::Ones(rows,cols) // ones(rows,cols)C.setOnes(rows,cols) // C = ones(rows,cols)MatrixXd::Random(rows,cols) // rand(rows,cols)*2-1 // MatrixXd::Random returns uniform random numbers in (-1, 1).C.setRandom(rows,cols) // C = rand(rows,cols)*2-1VectorXd::LinSpaced(size,low,high) // linspace(low,high,size)&#x27;v.setLinSpaced(size,low,high) // v = linspace(low,high,size)&#x27;// Matrix slicing and blocks. All expressions listed here are read/write.// Templated size versions are faster. Note that Matlab is 1-based (a size N// vector is x(1)...x(N)).// Eigen // Matlabx.head(n) // x(1:n)x.head&lt;n&gt;() // x(1:n)x.tail(n) // x(end - n + 1: end)x.tail&lt;n&gt;() // x(end - n + 1: end)x.segment(i, n) // x(i+1 : i+n)x.segment&lt;n&gt;(i) // x(i+1 : i+n)P.block(i, j, rows, cols) // P(i+1 : i+rows, j+1 : j+cols)P.block&lt;rows, cols&gt;(i, j) // P(i+1 : i+rows, j+1 : j+cols)P.row(i) // P(i+1, :)P.col(j) // P(:, j+1)P.leftCols&lt;cols&gt;() // P(:, 1:cols)P.leftCols(cols) // P(:, 1:cols)P.middleCols&lt;cols&gt;(j) // P(:, j+1:j+cols)P.middleCols(j, cols) // P(:, j+1:j+cols)P.rightCols&lt;cols&gt;() // P(:, end-cols+1:end)P.rightCols(cols) // P(:, end-cols+1:end)P.topRows&lt;rows&gt;() // P(1:rows, :)P.topRows(rows) // P(1:rows, :)P.middleRows&lt;rows&gt;(i) // P(:, i+1:i+rows)P.middleRows(i, rows) // P(:, i+1:i+rows)P.bottomRows&lt;rows&gt;() // P(:, end-rows+1:end)P.bottomRows(rows) // P(:, end-rows+1:end)P.topLeftCorner(rows, cols) // P(1:rows, 1:cols)P.topRightCorner(rows, cols) // P(1:rows, end-cols+1:end)P.bottomLeftCorner(rows, cols) // P(end-rows+1:end, 1:cols)P.bottomRightCorner(rows, cols) // P(end-rows+1:end, end-cols+1:end)P.topLeftCorner&lt;rows,cols&gt;() // P(1:rows, 1:cols)P.topRightCorner&lt;rows,cols&gt;() // P(1:rows, end-cols+1:end)P.bottomLeftCorner&lt;rows,cols&gt;() // P(end-rows+1:end, 1:cols)P.bottomRightCorner&lt;rows,cols&gt;() // P(end-rows+1:end, end-cols+1:end)// Of particular note is Eigen&#x27;s swap function which is highly optimized.// Eigen // MatlabR.row(i) = P.col(j); // R(i, :) = P(:, i)R.col(j1).swap(mat1.col(j2)); // R(:, [j1 j2]) = R(:, [j2, j1])// Views, transpose, etc; all read-write except for .adjoint().// Eigen // MatlabR.adjoint() // R&#x27;R.transpose() // R.&#x27; or conj(R&#x27;)R.diagonal() // diag(R)x.asDiagonal() // diag(x)R.transpose().colwise().reverse(); // rot90(R)R.conjugate() // conj(R)// All the same as Matlab, but matlab doesn&#x27;t have *= style operators.// Matrix-vector. Matrix-matrix. Matrix-scalar.y = M*x; R = P*Q; R = P*s;a = b*M; R = P - Q; R = s*P;a *= M; R = P + Q; R = P/s; R *= Q; R = s*P; R += Q; R *= s; R -= Q; R /= s;// Vectorized operations on each element independently// Eigen // MatlabR = P.cwiseProduct(Q); // R = P .* QR = P.array() * s.array();// R = P .* sR = P.cwiseQuotient(Q); // R = P ./ QR = P.array() / Q.array();// R = P ./ QR = P.array() + s.array();// R = P + sR = P.array() - s.array();// R = P - sR.array() += s; // R = R + sR.array() -= s; // R = R - sR.array() &lt; Q.array(); // R &lt; QR.array() &lt;= Q.array(); // R &lt;= QR.cwiseInverse(); // 1 ./ PR.array().inverse(); // 1 ./ PR.array().sin() // sin(P)R.array().cos() // cos(P)R.array().pow(s) // P .^ sR.array().square() // P .^ 2R.array().cube() // P .^ 3R.cwiseSqrt() // sqrt(P)R.array().sqrt() // sqrt(P)R.array().exp() // exp(P)R.array().log() // log(P)R.cwiseMax(P) // max(R, P)R.array().max(P.array()) // max(R, P)R.cwiseMin(P) // min(R, P)R.array().min(P.array()) // min(R, P)R.cwiseAbs() // abs(P)R.array().abs() // abs(P)R.cwiseAbs2() // abs(P.^2)R.array().abs2() // abs(P.^2)(R.array() &lt; s).select(P,Q); // (R &lt; s ? P : Q)// Reductions.int r, c;// Eigen // MatlabR.minCoeff() // min(R(:))R.maxCoeff() // max(R(:))s = R.minCoeff(&amp;r, &amp;c) // [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);s = R.maxCoeff(&amp;r, &amp;c) // [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);R.sum() // sum(R(:))R.colwise().sum() // sum(R)R.rowwise().sum() // sum(R, 2) or sum(R&#x27;)&#x27;R.prod() // prod(R(:))R.colwise().prod() // prod(R)R.rowwise().prod() // prod(R, 2) or prod(R&#x27;)&#x27;R.trace() // trace(R)R.all() // all(R(:))R.colwise().all() // all(R)R.rowwise().all() // all(R, 2)R.any() // any(R(:))R.colwise().any() // any(R)R.rowwise().any() // any(R, 2)// Dot products, norms, etc.// Eigen // Matlabx.norm() // norm(x). Note that norm(R) doesn&#x27;t work in Eigen.x.squaredNorm() // dot(x, x) Note the equivalence is not true for complexx.dot(y) // dot(x, y)x.cross(y) // cross(x, y) Requires #include &lt;Eigen/Geometry&gt;//// Type conversion// Eigen // MatlabA.cast&lt;double&gt;(); // double(A)A.cast&lt;float&gt;(); // single(A)A.cast&lt;int&gt;(); // int32(A)A.real(); // real(A)A.imag(); // imag(A)// if the original type equals destination type, no work is done// Note that for most operations Eigen requires all operands to have the same type:MatrixXf F = MatrixXf::Zero(3,3);A += F; // illegal in Eigen. In Matlab A = A+F is allowedA += F.cast&lt;double&gt;(); // F converted to double and then added (generally, conversion happens on-the-fly)// Eigen can map existing memory into Eigen matrices.float array[3];Vector3f::Map(array).fill(10); // create a temporary Map over array and sets entries to 10int data[4] = &#123;1, 2, 3, 4&#125;;Matrix2i mat2x2(data); // copies data into mat2x2Matrix2i::Map(data) = 2*mat2x2; // overwrite elements of data with 2*mat2x2MatrixXi::Map(data, 2, 2) += mat2x2; // adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)// Solve Ax = b. Result stored in x. Matlab: x = A \\ b.x = A.ldlt().solve(b)); // A sym. p.s.d. #include &lt;Eigen/Cholesky&gt;x = A.llt() .solve(b)); // A sym. p.d. #include &lt;Eigen/Cholesky&gt;x = A.lu() .solve(b)); // Stable and fast. #include &lt;Eigen/LU&gt;x = A.qr() .solve(b)); // No pivoting. #include &lt;Eigen/QR&gt;x = A.svd() .solve(b)); // Stable, slowest. #include &lt;Eigen/SVD&gt;// .ldlt() -&gt; .matrixL() and .matrixD()// .llt() -&gt; .matrixL()// .lu() -&gt; .matrixL() and .matrixU()// .qr() -&gt; .matrixQ() and .matrixR()// .svd() -&gt; .matrixU(), .singularValues(), and .matrixV()// Eigenvalue problems// Eigen // MatlabA.eigenvalues(); // eig(A);EigenSolver&lt;Matrix3d&gt; eig(A); // [vec val] = eig(A)eig.eigenvalues(); // diag(val)eig.eigenvectors(); // vec// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"CMakeLists.txt中声明使用C++11标准","slug":"20170509-CMakeLists.txt-使用C++11标准","date":"2017-05-09T04:05:32.000Z","updated":"2021-05-04T14:12:19.683Z","comments":true,"path":"2017/05/09/20170509-CMakeLists.txt-使用C++11标准/","link":"","permalink":"http://example.com/2017/05/09/20170509-CMakeLists.txt-%E4%BD%BF%E7%94%A8C++11%E6%A0%87%E5%87%86/","excerpt":"","text":"在CMakeLists.txt中添加如下代码： 1add_definitions(-std&#x3D;c++11) 即可。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"http://example.com/tags/cmake/"},{"name":"c++11","slug":"c-11","permalink":"http://example.com/tags/c-11/"}]},{"title":"Git命令行操作指南——上传项目","slug":"20170509-Git-命令使用指南","date":"2017-05-09T01:24:07.000Z","updated":"2021-05-04T14:27:35.663Z","comments":true,"path":"2017/05/09/20170509-Git-命令使用指南/","link":"","permalink":"http://example.com/2017/05/09/20170509-Git-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"假设已经在github上创建了项目名，地址为:https://github.com/xx/xx.git 1.创建项目目录并初始化123mkdir *** #项目文件夹cd ***git init 2.将所有文件添加到暂存区1git add . 3.将暂存区的文件提交至本地仓库1git commit -m “注释&quot; 4.将本地仓库关联到Github上1git remote add origin https://github.com/xx/xx.git 5.将代码由本地仓库上传到Github远程仓库12git pull --rebase origin mastergit push -u origin master","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"Hexo文章排序","slug":"20170502-Hexo文章排序","date":"2017-05-02T06:10:35.000Z","updated":"2021-05-04T14:12:00.151Z","comments":true,"path":"2017/05/02/20170502-Hexo文章排序/","link":"","permalink":"http://example.com/2017/05/02/20170502-Hexo%E6%96%87%E7%AB%A0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"修改文件夹中的 node_modules/hexo-generator-index/lib/generator.js文件，在var posts一句后面加入如下代码 1234567891011posts.data &#x3D; posts.data.sort(function(first, second) &#123; if (first.top &amp;&amp; second.top) &#123; &#x2F;&#x2F; 两篇文章top都有定义 return first.top &#x3D;&#x3D; second.top ? second.date - first.date : second.top - first.top &#x2F;&#x2F;若top值一样则按照文章日期降序排, 否则按照top值降序排 &#125; else if (first.top &amp;&amp; !second.top) &#123; &#x2F;&#x2F; 以下是只有一篇文章top有定义，将有top的排在前面 return -1; &#125; else if (!first.top &amp;&amp; second.top) &#123; return 1; &#125; else &#123; return second.date - first.date; &#x2F;&#x2F; 都没定义top，按照文章日期降序排 &#125; &#125;); 修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334&#39;use strict&#39;;var pagination &#x3D; require(&#39;hexo-pagination&#39;);module.exports &#x3D; function(locals) &#123; var config &#x3D; this.config; var posts &#x3D; locals.posts.sort(config.index_generator.order_by); posts.data &#x3D; posts.data.sort(function(first, second) &#123; if (first.top &amp;&amp; second.top) &#123; return first.top &#x3D;&#x3D; second.top ? second.date - first.date : second.top - first.top &#125; else if (first.top &amp;&amp; !second.top) &#123; return -1; &#125; else if (!first.top &amp;&amp; second.top) &#123; return 1; &#125; else &#123; return second.date - first.date; &#125; &#125;); var paginationDir &#x3D; config.pagination_dir || &#39;page&#39;; var path &#x3D; config.index_generator.path || &#39;&#39;; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: [&#39;index&#39;, &#39;archive&#39;], format: paginationDir + &#39;&#x2F;%d&#x2F;&#39;, data: &#123; __index: true &#125; &#125;);&#125;; 2.在Markdown文件头位置，加入如下配置 1top: 数字 #数字越大，排名越靠前。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Hexo 建立个人博客","slug":"20170501-Hexo-建立个人博客","date":"2017-05-01T06:17:35.000Z","updated":"2021-05-04T14:11:50.779Z","comments":true,"path":"2017/05/01/20170501-Hexo-建立个人博客/","link":"","permalink":"http://example.com/2017/05/01/20170501-Hexo-%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"假设已经在github上创建了项目，项目名为abc.github.io Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1. 安装Git1sudo apt-get install git 2. 安装nodejs12sudo apt-get install nodejssudo apt-get install npm 3. 安装hexo安装hexo，输入命令 123mkdir myblogcd myblognpm install -g hexo-cli 初始化hexo 12hexo init myblognpm install 完成后，文件夹目录包含如下： 123456node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件 123hexo cleanhexo ghexo s 清理、生成网页，打开hexo的服务，在浏览器输入localhost:4000可以看到生成的博客。 4. GitHub创建个人仓库注册并登录github后，新建仓库New repository 创建与用户名相同的仓库，如：abc.github.io，其中abc为GitHub用户名。 点击create repository。 5. 生成SSH添加到GitHub回到shell，输入以下命令： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; yourname为GitHub的用户名，youremail为GitHub的邮箱，该操作用于github对用户名和邮箱信息进行匹配验证。 检查上述name和email是否正确 12git config user.namegit config user.email 创建SSH 1ssh-keygen -t rsa -C &quot;youremail&quot; 生成~/.ssh的文件夹及密钥文件。 在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key。 复制SSH生成的id_rsa.pub中的信息并粘贴到文本框中。 6. 将hexo部署到GitHub运行如下命令，适中保存github用户名和密码 1git config --global credential.helper store 修改配置文件_config.yml 1234deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;abc.github.io.git branch: main 安装deploy-git 1npm install hexo-deployer-git --save 使用hexo命令清理、生成、部署博客网页 123hexo cleanhexo ghexo d 必要时输入username和password。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Create New Page","slug":"20170420-CreateNewPage","date":"2017-04-20T06:17:35.000Z","updated":"2021-05-04T14:34:01.855Z","comments":true,"path":"2017/04/20/20170420-CreateNewPage/","link":"","permalink":"http://example.com/2017/04/20/20170420-CreateNewPage/","excerpt":"","text":"This is the title.This is an image This is a code block.123456int fun(int x, int y)&#123; int z = -32768; z = x + y; return z;&#125; This is a table. Variable Value a 10 b 20 This is a math equation$$ \\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$$","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/categories/MCU/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"http://example.com/tags/MCU/"},{"name":"HDF5","slug":"HDF5","permalink":"http://example.com/tags/HDF5/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"cmake","slug":"cmake","permalink":"http://example.com/tags/cmake/"},{"name":"c++11","slug":"c-11","permalink":"http://example.com/tags/c-11/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}